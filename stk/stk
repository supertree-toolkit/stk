#!/usr/bin/env python
#
#    Supertree Toolkit. Software for managing and manipulating sources
#    trees ready for supretree construction.
#    Copyright (C) 2011-2017, Jon Hill, Katie Davis
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Jon Hill. jon.hill@york.ac.uk. 

import os
import sys
import argparse
import traceback
import time
try:
    __file__
except NameError:
    __file__ = "."
if (not sys.platform.startswith("win")):
    stk_path = os.path.join( os.path.realpath(os.path.dirname(__file__)), os.pardir )
    sys.path.insert(0, stk_path)
    stk_path = os.path.join( os.path.realpath(os.path.dirname(__file__)), os.pardir ,os.pardir)
    sys.path.insert(0, stk_path)
else:
    stk_path = os.getcwd()
import stk as supertree_toolkit
import stk.Getch as Getch
import string
import stk.p4 as p4
import lxml
import csv
import tempfile
from subprocess import check_call, CalledProcessError, call

import stk.bzr_version as bzr_version
d = bzr_version.version_info
build = d.get('revno','<unknown revno>')
date  = d.get('build_date','<unknown build date>')
branch = d.get("branch_nick","<unknown branch>")

# Set up a global Getch class for all functions to use
inkey = Getch._Getch()

# STK is the main command line program for the supertree toolkit
# Using the XML files created by the GUI it can processes the data, without
# launching the GUI - useful for batch processing or tasks that might take a while.
def main():

    parser = argparse.ArgumentParser(
         prog="stk",
         description="""stk is the command line interface to the supertree toolkit. """+
                     """It can access all the functionality of the STK that is available in """+
                     """the GUI. """
                     )
    parser.add_argument(
            '-v', 
            '--verbose', 
            action='store_true', 
            help="Verbose output: mainly progress reports.",
            default=False
            )
    parser.add_argument(
            '-i', 
            '--ignoreWarnings', 
            action='store_true', 
            help="Ignore warnings about data quality",
            default=False
            )
    parser.add_argument(
            '--version', 
            action='store_true', 
            help="Print version number and exit",
            default=False
            )

    subparsers = parser.add_subparsers(help='sub-command help')
    # Here's how we add a new sub-command
    #
    # Add a subparser, with some help and a command
    parser_cm = subparsers.add_parser('create_matrix',
            help='Create a TNT or Nexus matrix'
            )
    # Now add the command line args for this command
    # These arguments are not-optional
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output matrix file')
    # This one is optional
    parser_cm.add_argument('-f',
            '--format', 
            choices=['hennig', 'nexus'],
            help='The format of the matrix. hennig or nexus. Default is hennig')
    parser_cm.add_argument('-q',
            '--quote', 
            action='store_true',
            default=False,
            help='Quote taxa names in the matrix')    
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.add_argument('--taxonomy',
            help="Add an additional tree file containig a taxonomy backbone tree into the matrix.")
    parser_cm.add_argument('--remove_outgroups',
            help="Remove outgroups of the source trees before making the matrix.",
            action='store_true',
            default=False,            
            )
    # Set the function that gets called when the sub command is activated
    parser_cm.set_defaults(func=create_matrix)


    # substitue taxa command
    parser_cm = subparsers.add_parser('sub_taxa',
            help='Substitute or delete taxa from the file'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output phyml file')
    parser_cm.add_argument('-e',
            '--only_existing',
            action='store_true',
            default=False,
            help="Only substitute in taxa already in the dataset")
    parser_cm.add_argument('-g',
            '--generic',
            action='store_true',
            default=False,
            help="When using only existing, matches to genera level are accepted as existing")
    parser_cm.add_argument('-s',
            '--subs', 
            help='A substitution file. See manual for format.')
    parser_cm.add_argument('-n',
            '--newtaxon', 
            help='The new taxon. If you want to delete, leave blank.')
    parser_cm.add_argument('-o',
            '--oldtaxon', 
            help='The old taxon. Must be in the dataset.')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.set_defaults(func=sub_taxa)

    
    # import data command
    parser_cm = subparsers.add_parser('import_data',
            help='Import data from old STK dataset.'
            )
    parser_cm.add_argument('input',
            help='The input directory')
    parser_cm.add_argument('output', 
            help='The output phyml file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.set_defaults(func=import_data)


    # export data command
    parser_cm = subparsers.add_parser('export_data',
            help='Export data to old STK dataset.'
            )
    parser_cm.add_argument('input',
            help='The input file')
    parser_cm.add_argument('output', 
            help='The output directory')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing directory without asking for confirmation")
    parser_cm.set_defaults(func=export_data) 


    # export trees command
    parser_cm = subparsers.add_parser('export_trees',
            help='Export all tree in data to single tree file'
            )
    parser_cm.add_argument('input',
            help='The input Phyml file')
    parser_cm.add_argument('output', 
            help='The output tree file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing directory without asking for confirmation")
    # This one is optional
    parser_cm.add_argument('-f',
            '--format', 
            choices=["nexus","newick","tnt"],
            default="nexus",
            help='The format of the tree file. nexus, newick or tnt. Default is Nexus')
    parser_cm.add_argument('--anonymous',
            '-a',
            action='store_true',
            default=False,
            help="Anonymise output file to remove source names. Only works for Nexus files; otherwise ignored.")
    parser_cm.set_defaults(func=export_trees) 

    # export trees command
    parser_cm = subparsers.add_parser('export_bib',
            help='Export all bibliographic data to a file'
            )
    parser_cm.add_argument('input',
            help='The input Phyml file')
    parser_cm.add_argument('output', 
            help='The output bibliographic file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing directory without asking for confirmation")
    # This one is optional
    parser_cm.add_argument('-f',
            '--format', 
            choices=["bibtex","latex","html","short","long","xml"],
            default="bibtex",
            help="""The format of the bibliographic file. Default is bibtex.
                    Choice is from bibtex, latex, html, short, long, xml."""
            )
    parser_cm.set_defaults(func=export_bib) 

    # Data summary command
    parser_cm = subparsers.add_parser('data_summary',
            help='Summary of this dataset'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('-o',
            '--output',
            default=False,
            const=True,
            nargs='?',
            help='Save output to a file, rather than to screen. '+
            'If no file is specified, the summary is saved to the input file directory '+
            'as "data_summary.txt" otherwise the given filename is used.')
    parser_cm.add_argument('-d',
            '--detailed',
            action='store_true',
            default=False,
            help="Output a detailed version of the summary")
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing files without asking for confirmation")
    parser_cm.set_defaults(func=data_summary)

    
    parser_cm = subparsers.add_parser('safe_taxonomic_reduction',
            help='Perform safe taxonomic reduction on the data')
    parser_cm.add_argument('-s',
            '--subs', 
            help="""Create two subs file to delete the data with sub_taxa and to replace C category"""+
                  """taxa back in afterwards. Supply a directory.
                  The files withh be called sub_delete and sub_replace""")
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing files without asking for confirmation")
    parser_cm.add_argument('--matrix',
            '-m',
            action='store_true',
            default=False,
            help="The input file is a matrix, not a PHYML")
    parser_cm.add_argument('-o',
            '--output', 
            help='Output to file, rather than stdout') 
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.set_defaults(func=safe_taxonomic_reduction)


    # Independence check for source trees.
    parser_cm = subparsers.add_parser('data_ind',
            help='Check the independence of source trees within this dataset.')
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing files without asking for confirmation")
    parser_cm.add_argument('-o',
            '--output',
            default=False,
            const=True,
            nargs='?',
            required=False,
            help='Save output to a file, rather than to screen. '+
            'If no file is specified, the summary is saved to the input file directory '+
            'as "data_ind.txt" otherwise the given filename is used. See the manual on how to '+
            'interpret these files.')
    parser_cm.add_argument('-n',
            '--newphyml', 
            required=False,
            help='Provide a new PHYML file with the trees that are a subset of other trees removed. The ' +
            'trees that are identical to other trees are still in the data. Please provide a filename.')
    parser_cm.set_defaults(func=data_ind)


    # Data overlap command
    parser_cm = subparsers.add_parser('data_overlap',
            help='Check these data are sufficiently well connected'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('-n',
            '--number_overlap',
            type=int,
            help="Number of taxa in common for two trees to be connected. Default is 2.",
            required=False,
            )
    parser_cm.add_argument('-g',
            '--graphic',
            default=None,
            const=True,
            nargs='?',
            help='Save a graphical representation of the connectivity. This is in the form of a graph. '+
            'You can specifiy a file name, or a filename will be automatically generated for you and '+
            'saved in the same directory as the input file. A key.csv file will also be generated.')
    parser_cm.add_argument('-d',
            '--detailed',
            action='store_true',
            default=False,
            help="Output a detailed version of the graph. For more than 200 source trees this could take a while.")
    parser_cm.set_defaults(func=data_overlap)


    # Permute trees command
    parser_cm = subparsers.add_parser('permute_trees',
            help='Create all possible trees from sources that contain non-monophyly. See manual for details.'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output tree or matrix file(s). If multiple files are produced the sourcename will be appended to the filename.')
    parser_cm.add_argument('-c',
            '--create_matrix',
            choices=['hennig', 'nexus'],
            help="Create a matrix of the given format for all permutable trees in the input file.",
            required=False,
            )
    parser_cm.add_argument('-t',
            '--treefile',
            choices=['nexus','newick','tnt'],
            help="Create a tree file of the given format for all permutable trees in the input file.",
            required=False,
            )
    parser_cm.add_argument('-n',
            '--treename',
            default=None,
            help="Do the permutation on a single tree only. Format of the name is Sourcename_treenumber, e.g. 'Hill_etal_2011_1'",
            required=False,
            )
    parser_cm.set_defaults(func=permute_trees)

    # Clean data
    parser_cm = subparsers.add_parser('clean_data',
            help='Renames all sources and trees sensibly. Removes errant taxa, uninformative trees and empty sources.'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output phyml file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.set_defaults(func=clean_data)

    # Replace genera
    parser_cm = subparsers.add_parser('replace_genera',
            help='Replace higher order (generic) taxa with a polytomy of specific taxa'
            )
    parser_cm.add_argument('input', 
            help='The input phyml file')
    parser_cm.add_argument('output', 
            help='The output phyml file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.add_argument('--only_subs',
            action='store_true',
            default=False,
            help="Don't carry out the subs, but generate a subs file as output instead")
    parser_cm.set_defaults(func=replace_genera)


    # convert files
    parser_cm = subparsers.add_parser('convert_files',
            help='Convert tree or matrix files to other formats'
            )
    parser_cm.add_argument('input', 
            help='The input file')
    parser_cm.add_argument('output', 
            help='The output file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.add_argument('--format',
            choices=['nexus','newick','tnt'],
            help="Create the output file of the given format. Default is nexus. Newick doesn't make sense for matrix files.",
            required=False,
            default='nexus',
            )
    parser_cm.set_defaults(func=convert_file)


    # create subset
    parser_cm = subparsers.add_parser('create_subset',
            help="""Create a subset from the PHYML containing only certain years, characters, 
                    taxa or analyses. Use the data summary command to see all the data, such 
                    as characters, that are present in your data. By default does an "and" search' and 
                    allows matches when trees contain the desired character type and other types. See 
                    manual for examples. Note you may need an extra -- after your options if you get
                    invalid option errors."""
            )
    parser_cm.add_argument('input', 
            help='The input file')
    parser_cm.add_argument('output', 
            help='The output file')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.add_argument('--years',
            help="Only include data with these years. You can add multiple years per --year flag, use multiple --year flags and/or use ranges, e.g. 2010-2013",
            required=False,
            nargs="*",
            )
    parser_cm.add_argument('--taxa',
            help="Only include data with these taxa. You can add multiple --taxa per flag or use multiple --taxa flags",
            required=False,
            nargs="*",
            )
    parser_cm.add_argument('--character_types',
            help="Only include data with these character_types. You can add multiple --character_types or use multiple --character_types flags. Choices are molecular, morphological, behavioural, other",
            choices=['molecular', 'morphological', 'behavioural', 'other'],
            nargs="*",
            required=False,
            )
    parser_cm.add_argument('--characters',
            help="Only include data with these characters. You can add multiple --characters per flag or use multiple --character flags",
            required=False,
            nargs="*",
            )
    parser_cm.add_argument('--analyses',
            help="Only include data created with these analyses. You can add multiple --analyses per flag or use multiple --analyses flags",
            required=False,
            nargs="*",
            )
    parser_cm.add_argument('--fossil',
            help="Set fossils to all_extant (no fossils) or all_fossil. Default is that a mix is allowed and requires no option.",
            choices=['all_extant','all_fossil'],    
            required=False,
            )
    parser_cm.add_argument('--or',
            dest="or_search", 
            action='store_true',
            default=False,
            help="Apply search terms using 'or'. Default is 'and'.")
    parser_cm.add_argument('--only',
            action='store_true',
            default=False,
            help="Apply character and character types search such that the tree must contain *only* the desired terms."
            )
    parser_cm.set_defaults(func=create_subset)


    parser_cm = subparsers.add_parser('check_subs',
            help="""Check a subs file against a dataset and warn the user 
                 about the addition of taxa not already in the dataset
                 """)
    parser_cm.add_argument('input',
            help='The input Phyml file')
    parser_cm.add_argument('subs',
            help='The subs file')
    parser_cm.set_defaults(func=check_subs)
   
    # taxonomic name checker
    parser_cm = subparsers.add_parser('check_otus',
            help='Check your OTUs against EoL.'
            )
    parser_cm.add_argument('input',
            help='The input Phyml. Also accepts tree files or a simple list')
    parser_cm.add_argument('output', 
            help='The output CSV file. Taxon, synonyms, status')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.set_defaults(func=check_otus)

    # create taxonomy csv file
    parser_cm = subparsers.add_parser('create_taxonomy',
            help='Create a taxonomy file in CSV for you to then augment.'
            )
    parser_cm.add_argument('input',
            help='The input Phyml. Also accepts tree files or a simple list')
    parser_cm.add_argument('output', 
            help='The output CSV file. Name, followed by classification and source')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.add_argument('--taxonomy',
            help="Give a starting taxonomy file, e.g. one you ran earlier",)
    parser_cm.set_defaults(func=create_taxonomy)


    # do the subs in a one go using taxonomy
    parser_cm = subparsers.add_parser('auto_subs',
            help='Using a taxonomy, generate a species level version of your data in one go.'
            )
    parser_cm.add_argument('input',
            help='The input Phyml')
    parser_cm.add_argument('taxonomy',
            help='Your taxonomy file',
            )
    parser_cm.add_argument('output', 
            help='The output phyml')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    #parser_cm.add_argument('--level',
    #        choices=supertree_toolkit.taxonomy_levels,
    #        help="Taxonomic level to output at",)
    parser_cm.set_defaults(func=auto_subs)


    # attempt to process the data into a matrix all automatically
    parser_cm = subparsers.add_parser('process',
            help='Generate a species-level matrix, and do all the checks and processing automatically. Note this creates a taxonomy and does all the processing, but will not be perfect (as taxonomies are not perfect)'
            )
    parser_cm.add_argument('input',
            help='The input Phyml')
    parser_cm.add_argument('output', 
            help='The output matrix')
    parser_cm.add_argument('--taxonomy_file',
            help='Existing taxonomy file to prevent redownloading data. Any taxa not in the file will be checked online, so partial complete file are OK.')
    parser_cm.add_argument('--equivalents_file',
            help='Existing equivalents file from a taxonomic name check. Any taxa not in the file will be checked online, so partially complete files are OK.')
    parser_cm.add_argument('--overwrite',
            action='store_true',
            default=False,
            help="Overwrite the existing file without asking for confirmation")
    parser_cm.add_argument('--pref_db',
            choices=['eol', 'worms', 'itis'],
            default = 'eol'
            )
    parser_cm.add_argument('--no_store',
            action="store_true",
            default=False,
            help="Do not store intermediate files -- not recommended")
    parser_cm.set_defaults(func=process)


    # before we let argparse work its magic, check for --version
    if "--version" in sys.argv:
        branch = d.get("branch_nick","<unknown branch>")
        if (branch == "release"):
            branch = ""
        else:
            branch = ": ("+branch+")"
        print "STK version 2."+build+branch
        print "Built "+date
        print "Copyright (C) 2011-2017, Jon Hill, Katie Davis"
        print "Released under GNU General Public License"
        sys.exit(1)
    
    # parse the arguments, and strip out the common options
    args = parser.parse_args()
    verbose = args.verbose
    version = args.version

    # All of the rest may or may not apply to the command chosen
    # The rest of this function is effectively checking all of the arguments
    # against the command specified
    # Each command is given a function to execute via the "set_default" argument
    args.func(args)


def safe_taxonomic_reduction(args):
    """ Work out safe taxonomic reduction
    """
    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    subs = args.subs
    matrix_file = args.matrix
    ignoreWarnings = args.ignoreWarnings

    if (matrix_file and not os.path.exists(input_file)):
        print "Matrix file cannot be found"
        print "Exiting"
        sys.exit(-1)

    if not matrix_file:
        matrix = None
        taxa = None
        XML = supertree_toolkit.load_phyml(input_file)
    else:
        matrix,taxa = supertree_toolkit.read_matrix(input_file)
        XML = None
    try: 
        output, can_replace = supertree_toolkit.safe_taxonomic_reduction(XML,matrix=matrix,taxa=taxa,verbose=verbose,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to carry out STR.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to carry out STR.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to carry out STR.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return

    if (not subs == None or not subs):
        substitutions = supertree_toolkit.subs_file_from_str(output)
  
    if (output_file == None):
        print output
    else:
        f = open(output_file,"w")
        f.write(output)
        f.close()
    if (not subs == False or
        not subs == None):
            subs_replace = os.path.join(subs,"subs_replace")
            subs_delete = os.path.join(subs,"subs_delete")
            f = open(subs_replace, "w")
            for r in substitutions:
                f.write(r+"\n")
            f.close()
            f = open(subs_delete, "w")
            for d in can_replace:
                f.write(d+" = \n")
            f.close()

def data_ind(args):
    """ Check data independence
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    newphyml = args.newphyml
    overwrite = args.overwrite
    ignoreWarnings = args.ignoreWarnings

    if (output_file == True):
        # output file is set, but no file given
        # set to default
        # grab directory from input file
        path = os.path.abspath(input_file)
        direc = os.path.dirname(path)
        output_file = os.path.join(direc,"data_independence.txt")

    # check if output files are there
    if (output_file and os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break
    if (not newphyml == None and os.path.exists(newphyml) and not overwrite):
        print "Output Phyml file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)
    
    try:
        if (newphyml == None):
            data_independence, subsets = supertree_toolkit.data_independence(XML,ignoreWarnings=ignoreWarnings)
        else:
            data_independence, subsets, new_phyml = supertree_toolkit.data_independence(XML,make_new_xml=True,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to check independence.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to check independence.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to check independence.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except:
        msg = "***Error: failed to check independence due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit"
        print msg
        traceback.print_exc()
        return

    # process data
    data_ind = ""
    #column headers
    data_ind = "Source trees that are subsets of others\n"
    data_ind = data_ind + "Flagged tree(s), is/are subset(s) of:\n"
    for names in subsets:
        data_ind += ', '.join(str(e) for e in names[1:]) + " : " + names[0] + "\n"
    
    data_ind += "\n\nSource trees that are identical to others\n"
    data_ind = data_ind + "Flagged tree(s), is/are identical to:\n"
    for names in data_independence:
        data_ind += ', '.join(str(e) for e in names[1:]) + " : " + names[0] + "\n"
        

    if (output_file == False or
        output_file == None):
        print data_ind
    else:
        f = open(output_file, "w")
        f.write(data_ind)
        f.close()

    if (not newphyml == None):
        f = open(newphyml,"w")
        f.write(new_phyml)
        f.close()
        
def data_summary(args):
    """ Create a data summary
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    detailed = args.detailed
    ignoreWarnings = args.ignoreWarnings

    if (output_file == True):
        # output file is set, but no file given
        # set to default
        # grab directory from input file
        direc = os.path.dirname(input_file)
        output_file = direc + os.path.sep + "data_summary.txt"

    XML = supertree_toolkit.load_phyml(input_file)
    try:
        data_summary = supertree_toolkit.data_summary(XML,detailed=detailed,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to create data summary. Try again with -i flag.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to creae data summary. Try again with -i flag.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to create data summary. Try again with -i flag.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: Failed to summarise data - can't parse tree.\n"+detail.msg
        print msg
        return 
    except: 
        msg = "***Error: Failed to summarise data - incomplete data. Try again with -i flag.\n"
        print msg
        traceback.print_exc()
        return 


    if (output_file == False or
        output_file == None):
        print data_summary
    else:
        f = open(output_file, "w")
        f.write(data_summary)
        f.close()

def create_matrix(args):
    """ This function creates a phylogenetic matrix from a PHYML file
        by obtaining the tree strings contained in the file. """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    f_format = args.format
    overwrite = args.overwrite
    quote = args.quote
    ignoreWarnings = args.ignoreWarnings
    taxonomy = args.taxonomy
    remove_outgroups = args.remove_outgroups
    
    # check all the options
    if (f_format == None):
        f_format = 'hennig'

    if (not f_format == 'nexus' and
        not f_format == 'hennig'):
        print "Format must be one of 'hennig' or 'nexus'"
        sys.exit(-1)

    # Does the input file exist?
    if (not os.path.exists(input_file)):
        print "Input file cannot be found. Exiting"
        sys.exit(-1)

    # Does the output file already exist?
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break
    try:

        XML = supertree_toolkit.load_phyml(input_file)
        input_is_xml = True
    except:
        input_is_xml = False

    if (input_is_xml):
        XML = supertree_toolkit.load_phyml(input_file)
        if (not taxonomy == None):
            taxonomy_tree = None
            taxonomy_tree = supertree_toolkit.import_tree(taxonomy)
            taxonomy = taxonomy_tree
        try:
            matrix = supertree_toolkit.create_matrix(XML,format=f_format,quote=quote,taxonomy=taxonomy,
                                                     outgroups=remove_outgroups,ignoreWarnings=ignoreWarnings)
        except supertree_toolkit.NotUniqueError as detail:
            msg = "***Error: Failed to create matrix.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.InvalidSTKData as detail:
            msg = "***Error: Failed to create matrix.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.UninformativeTreeError as detail:
            msg = "***Error: Failed to create matrix.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.TreeParseError as detail:
            msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
            print msg
            return
        except: 
            msg = "***Error: Failed to create matrix due to unknown error.\n"
            print msg
            traceback.print_exc()
            return 
    else:
        # try trees!
        try:
            tree_list = supertree_toolkit.import_trees(input_file)
            trees = {}
            i = 0
            for t in tree_list:
                trees['tree_'+str(i)] = t
                i += 1
            matrix = supertree_toolkit.create_matrix_from_trees(trees,format=f_format)
        except supertree_toolkit.UninformativeTreeError as detail:
            msg = "***Error: Failed to create matrix.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.TreeParseError as detail:
            msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
            print msg
            return
        except: 
            msg = "***Error: Failed to create matrix due to unknown error.\n"
            print msg
            traceback.print_exc()
            return 

    f = open(output_file, "w")
    f.write(matrix)
    f.close()



def sub_taxa(args):
    """ Substitute or delete taxa from a PHYML file
    and make a new file with these taxa subbed/removed from all trees
    and XML
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    overwrite = args.overwrite
    subs_file = args.subs
    only_existing = args.only_existing
    generic = args.generic
    old_taxa = []
    new_taxa = []
    old_taxon = args.oldtaxon
    new_taxon = args.newtaxon
    ignoreWarnings = args.ignoreWarnings
    

    # check all the options
    # We need either a subs file *or* an old taxon, but not both
    if (old_taxon == None and subs_file == None):
        print "You need to supply either a subs file or an old_taxon"
        sys.exit(-1)
    if (old_taxon != None and subs_file != None):
        print "You need to supply either a subs file or an old_taxon, not both"
        sys.exit(-1)

    if (old_taxon != None):
        old_taxa.append(old_taxon)
        if (new_taxon != None):
            new_taxa.append(new_taxon)
        else:
            new_taxa.append(None)

    if (subs_file):
        if (subs_file.endswith(".csv")):
            try:
                old_taxa, new_taxa = supertree_toolkit.subs_from_csv(subs_file)
            except supertree_toolkit.UnableToParseSubsFile as e:
                print e.msg
                sys.exit(-1)
        else:
            try:
                old_taxa, new_taxa = supertree_toolkit.load_subs_file(subs_file)
            except supertree_toolkit.UnableToParseSubsFile as e:
                print e.msg
                sys.exit(-1)
    
   
    # Does the input file exist
    if (not os.path.exists(input_file)):
        print "Input file cannot be found. Exiting"
        sys.exit(-1)


    # Does the output file already exist?
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    treefile = False
    try:
        XML = supertree_toolkit.load_phyml(input_file)
    except lxml.etree.XMLSyntaxError:
        try:
            trees = supertree_toolkit.import_trees(input_file) 
            treefile = True
        except supertree_toolkit.TreeParseError as detail:
            print "Error loading file as PHYML or a tree file. Check your input, please"
            print detail.msg
            sys.exit(-1)
    try:
        if (treefile):
            new_trees_list = supertree_toolkit.substitute_taxa_in_trees(trees,old_taxa,new_taxa,only_existing=only_existing,generic_match=generic)
            new_trees = {}
            i = 1
            for t in new_trees_list:
                new_trees["tree_"+str(i)] = t
        else:
            XML = supertree_toolkit.substitute_taxa(XML,old_taxa,new_taxa,ignoreWarnings=ignoreWarnings,only_existing=only_existing,generic_match=generic)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed sbstituting taxa due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 


    if (treefile):
        output = supertree_toolkit.amalgamate_trees(new_trees,format='nexus')
        f = open(output_file,'w')
        f.write(output)
        f.close()
    else:
        # Add an event to the history of the file
        XML = supertree_toolkit.add_historical_event(XML, "Taxa substituted using command: " +" ".join(sys.argv)) 
        f = open(output_file,'w')
        f.write(XML)
        f.close()

    sys.exit(0)


# Note data import is *not* perfect due:
#   - more data in the new format
#   - more detail in new format for fossil data
#   - more comments and notes
def import_data(args):
    """ Import old (directory based) STK data into a PHYML file.
        Note the data copy is not perfect.
    """
    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_dir = args.input
    overwrite = args.overwrite

    if (not os.path.exists(input_dir)):
        print "Input directory cannot be found. Exiting"
        sys.exit(-1)

    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    try:
        phyml = supertree_import_export.import_old_data(input_dir,verbose=verbose) 
    except supertree_toolkit.STKImportExportError as e:
        print e.msg
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed sbstituting taxa due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 

    # Add an event to the history of the file
    phyml = supertree_toolkit.add_historical_event(phyml, "Data created using: "+ " ".join(sys.argv)) 
    f = open(output_file, "w")
    f.write(phyml)
    f.close()


def export_data(args):
    """ Export a PHYML to an old-style STK format (directory based).
    """
    # Parse the args
    verbose = args.verbose
    output_dir = args.output
    input_file = args.input
    ignoreWarnings = args.ignoreWarnings

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    XML = supertree_toolkit.load_phyml(input_file)
    try:
        supertree_import_export.export_to_old(XML,output_dir,verbose=verbose,ignoreWarnings=ignoreWarnings) 
    except supertree_toolkit.STKImportExportError as e:
        print e.msg
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to export data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to export data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to export data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed to export data due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 


def data_overlap(args):
    """ Check the data are sufficient well connected in terms of their taxonomic overlap
    """

    verbose = args.verbose
    input_file = args.input
    output_file = None
    ignoreWarnings = args.ignoreWarnings

    if args.number_overlap == None:
        overlap = 2
    else:
        overlap = args.number_overlap
    if args.graphic == None:
        graphic = False
    else:
        graphic = True
        if args.graphic == True:
            # generate filename
            filename =  os.path.splitext(input_file)[0]
            output_file = filename+"_"+str(overlap)+".pdf"
        else:
            output_file = args.graphic
            # check it ends in known graphics type
            extension = os.path.splitext(output_file)[1]
            if (not (extension == '.png' or extension == '.svg' or extension == '.pdf')):
                print "Warning: unknown output format. Correcting the output file you gave to .pdf"
                output_file = os.path.splitext(output_file)[0]+".pdf"

    XML = supertree_toolkit.load_phyml(input_file)
    try:
        overlap_ok, key_list = supertree_toolkit.data_overlap(XML,  overlap_amount=overlap, filename=output_file, detailed=args.detailed, verbose=verbose,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to check overlap.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to check overlap.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to check overlap.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed to check overlap due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 

    if (graphic):
        # generate key file
        filename =  os.path.splitext(output_file)[0]
        csv_file = filename+'_key_list_'+str(overlap)+".csv"
        i = 0
        f = open(csv_file,"w")
        for key in key_list:
            if type(key).__name__=='list':
                f.write(str(i)+","+",".join(key)+"\n")
            if type(key).__name__=='set':
                key = list(key)
                f.write(str(i)+","+",".join(key)+"\n")
            else:
                f.write(str(i)+","+key+"\n")
            i = i+1
        f.close()
    
    if (overlap_ok):
        print "Your data are sufficently well connected"
    else:
        print "Your data are *not* well connected. Run with -g (and perhaps -d) to see which trees need to be removed"

    return

def export_trees(args):
    """ Export source trees to a single tree file
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    format = args.format
    anon = args.anonymous
    overwrite = args.overwrite
    ignoreWarnings = args.ignoreWarnings

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    # check if output files are there
    if (output_file and os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)

    try:
        output_string = supertree_toolkit.export_trees(XML,format=format,anonymous=anon,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to export trees.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to export trees.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to export trees.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed to export trees due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 

    f = open(output_file,"w")
    f.write(output_string)
    f.close()



def export_bib(args):
    """ Export bibliographic information to a file
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    format = args.format
    overwrite = args.overwrite

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    # check if output files are there
    if (output_file and os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)

    output_string = supertree_toolkit.export_bibliography(XML,output_file,format=format)



def permute_trees(args):
    """ Create all possible permutations of permutable trees in the input file.
    Permutable trees have non-monophyletic taxa labelled with %d.
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    create_matrix = args.create_matrix
    treefile = args.treefile
    name = args.treename

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    XML = supertree_toolkit.load_phyml(input_file)

    tree_list = {}
    all_trees = supertree_toolkit.get_all_trees(XML)
    if (not name == None): # user has supplied a tree name - find it
        # get tree
        for t in all_trees:
            if t == name:
                tree_list[t] = all_trees[t]
        if (len(tree_list) == 0):
            print "Error finding that name. It should be in the form 'Hill_2011_1' or 'Hill_etal_2011_1' Note the lower case etal."
            sys.exit(-1)
    else:
        # get all permutable trees
        try:
            tree_list = supertree_toolkit.find_trees_for_permuting(XML)
        except supertree_toolkit.TreeParseError as detail:
            msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
            print msg
            return
        except:
            msg = "***Error: Failed to extract a tree list to check for permutable.\n"
            print msg
            traceback.print_exc()
            return 

    if (verbose):
        print "List of trees to permute:"
        for t in tree_list:
            print t

    for t in tree_list:
        # permute
        if (verbose):
            print "Permuting "+t
        try:
            if (not treefile == ''):
                output_string = supertree_toolkit.permute_tree(tree_list[t],treefile=treefile,verbose=verbose)
            else:
                output_string = supertree_toolkit.permute_tree(tree_list[t],matrix=create_matrix,treefile=None,verbose=verbose)
        except supertree_toolkit.NotUniqueError as detail:
            msg = "***Error: Failed to permute trees.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.InvalidSTKData as detail:
            msg = "***Error: Failed to permute trees.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.UninformativeTreeError as detail:
            msg = "***Error: Failed to permute trees.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.TreeParseError as detail:
            msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
            print msg
            return
        except: 
            msg = "***Error: Failed to permute trees due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
            print msg
            traceback.print_exc()
            return 


        #save
        if (not output_string == ""):
            filename = os.path.basename(output_file)
            dirname = os.path.dirname(output_file)
            new_output = os.path.join(dirname,t,filename)
            try: 
               os.makedirs(os.path.join(dirname,t))
            except OSError:
                if not os.path.isdir(os.path.join(dirname,t)):
                    raise
            f = open(new_output,'w')
            f.write(output_string)
            f.close
            

def clean_data(args):
    """ clean up the data
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    overwrite = args.overwrite

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    # check if output files are there
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)
    try:
        XML = supertree_toolkit.clean_data(XML)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to clean data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to clean data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to clean data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed to clean data due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 

    f = open(output_file, "w")
    f.write(XML)
    f.close()
    
def replace_genera(args):
    """ replace genera with a polytomy of species in that genera (if in data)
    """

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    overwrite = args.overwrite
    only_subs = args.only_subs
    ignoreWarnings = args.ignoreWarnings

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    # check if output files are there
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)
    try:
        XML,generic,subs = supertree_toolkit.replace_genera(XML,dry_run=only_subs,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to replace genera.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to replace genera.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to replace genera.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed to replace genera due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 

    f = open(output_file, "w")
    if (only_subs):
        i = 0
        for g in generic:
            f.write(g+" = "+subs[i]+"\n")
            i+=1
    else:
        f.write(XML)
    f.close()


def convert_file(args):

    # Parse the args
    verbose = args.verbose
    output_file = args.output
    input_file = args.input
    overwrite = args.overwrite
    output_format = args.format

    # open file and decide if tree or matrix
    try:
        f = open(input_file,"r")
    except:
        print "Unable to open file " + input_file
        sys.exit(-1)
    data = f.read()
    data = data.lower()
    if (not data.find('xread') == -1 or not data.find('matrix') == -1 and data.find('tree') == -1):
        matrix = True
    else:
        matrix = False


    if (matrix):
        try:
            matrix, taxa = supertree_toolkit.read_matrix(input_file)
            if (output_format == "tnt"):
                output_format = 'hennig'
            output = supertree_toolkit.create_matrix_string(matrix,taxa,format=output_format)
        except:
            print "Error saving matrix"
            sys.exit(-1)
    else:
        try:
            trees = supertree_toolkit.import_trees(input_file)
            # turn trees into dict
            new_trees = {}
            i = 1
            for t in trees:
                new_trees['tree_'+str(i)] = supertree_toolkit.collapse_nodes(t)
                i += 1
            output = supertree_toolkit.amalgamate_trees(new_trees,format=output_format)
        except supertree_toolkit.TreeParseError as detail:
            print detail.msg
            sys.exit(-1)
        except:
            print "Error converting tree"
            traceback.print_exc()
            sys.exit(-1)


    # check if output files are there
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break    
    f = open(output_file, "w")
    f.write(output)
    f.close()


def create_subset(args):

    # Parse the args
    verbose = args.verbose
    ignoreWarnings = args.ignoreWarnings
    output_file = args.output
    input_file = args.input
    overwrite = args.overwrite
    years = args.years
    taxa = args.taxa
    character_types = args.character_types
    characters = args.characters
    analyses = args.analyses
    andSearch = not args.or_search
    includeMultiple = not args.only
    fossil = args.fossil

    if (not os.path.exists(input_file)):
        print "Input phyml cannot be found. Exiting"
        sys.exit(-1)

    # check if output files are there
    if (os.path.exists(output_file) and not overwrite):
        print "Output file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    if (years == None):
        years = []
    if (taxa == None):
        taxa = []
    if (character_types == None):
        character_types = []
    if (characters == None):
        characters = []
    if (analyses == None):
        analyses = []


    # The search function does all the hard work, we just need to create the search dictionary
    searchTerms = {'years':years,
                   'taxa':taxa,
                   'character_types': character_types,
                   'characters': characters,
                   'analyses': analyses,
                   'fossil' : fossil}
    XML = supertree_toolkit.load_phyml(input_file)

    try:
        new_XML = supertree_toolkit.create_subset(XML,searchTerms,andSearch=andSearch,includeMultiple=includeMultiple,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to create subset.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to create subset.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to create subset.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed to create subset due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 

    new_XML = supertree_toolkit.add_historical_event(new_XML, "Subset created with " +" ".join(sys.argv)) 
    
    
    f = open(output_file, "w")
    f.write(new_XML)
    f.close()


def check_subs(args):
    """check a subs file"""

    verbose = args.verbose
    subs_file = args.subs
    input_file = args.input

    XML = supertree_toolkit.load_phyml(input_file)
    if (subs_file.endswith(".csv")):
        try:
            old_taxa, new_taxa = supertree_toolkit.subs_from_csv(subs_file)
        except supertree_toolkit.UnableToParseSubsFile as e:
            print e.msg
            sys.exit(-1)
    else:
        try:
            old_taxa, new_taxa = supertree_toolkit.parse_subs_file(subs_file)
        except supertree_toolkit.UnableToParseSubsFile as e:
            print e.msg
            sys.exit(-1) 
    
    try:
        supertree_toolkit.check_subs(XML,new_taxa)
    except supertree_toolkit.AddingTaxaWarning as detail:
        print "**************************************************************"
        print "Warning: This substitution will add taxa to the dataset"
        print "**************************************************************\n"
        print detail.msg
        return

    print "**************************************************************"
    print "This subs file looks good. No additional taxa will be added."
    print "**************************************************************\n"


def check_otus(args):
    """check out the OTUs in the Phyml - are they considered valid?"""

    verbose = args.verbose
    input_file = args.input
    output_file = args.output

    print input_file
    if (input_file.endswith(".phyml")):
        XML = supertree_toolkit.load_phyml(input_file)
        try:
            equivs = supertree_toolkit.taxonomic_checker(XML, verbose=verbose)
        except supertree_toolkit.NotUniqueError as detail:
            msg = "***Error: Failed to check OTUs.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.InvalidSTKData as detail:
            msg = "***Error: Failed to check OTUs.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.UninformativeTreeError as detail:
            msg = "***Error: Failed to check OTUs.\n"+detail.msg
            print msg
            return
        except supertree_toolkit.TreeParseError as detail:
            msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
            print msg
            return
        except:
            # what about no internet conenction? What error do that throw?
            msg = "***Error: failed to create OTUs due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit"
            print msg
            traceback.print_exc()
            return
    elif (input_file.endswith(".txt") or input_file.endswith('.dat')):
        # read file - assume one taxa per line
        with open(input_file,'r') as f:
            lines = f.read().splitlines()        
        equivs = supertree_toolkit.taxonomic_checker_list(lines, verbose=verbose)
    else:
        # assume a tree!
        equivs = supertree_toolkit.taxonomic_checker_tree(input_file, verbose=verbose)



    f = open(output_file,"w")
    for taxon in sorted(equivs.keys()):
        f.write(taxon+","+";".join(equivs[taxon][0])+","+equivs[taxon][1]+"\n")
    f.close()



def create_taxonomy(args):
    """create a taxonomic heirachy for each OTU in the Phyml"""

    verbose = args.verbose
    input_file = args.input
    output_file = args.output
    existing_taxonomy = args.taxonomy
    ignoreWarnings = args.ignoreWarnings

    XML = supertree_toolkit.load_phyml(input_file)
    if (not existing_taxonomy == None):
        existing_taxonomy = supertree_toolkit.load_taxonomy(existing_taxonomy) # load it in and create the dictionary
        pass

    try:
        taxonomy = supertree_toolkit.create_taxonomy(XML,existing_taxonomy=existing_taxonomy,verbose=verbose,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to create taxonomy.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to create taxonomy.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to create taxonomy.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except:
        # what about no internet conenction? What error do that throw?
        msg = "***Error: failed to create taxonomy due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit"
        print msg
        traceback.print_exc()
        return
    
    # Now create the CSV output
    save_taxonomy(taxonomy, output_file)


def auto_subs(args):
    """Get all OTUs to the same taxonomic level"""

    
    verbose = args.verbose
    input_file = args.input
    output = args.output
    taxonomy = args.taxonomy
    ignoreWarnings = args.ignoreWarnings

    if (os.path.exists(output) and not overwrite):
        print "Output Phyml file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway?? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    XML = supertree_toolkit.load_phyml(input_file)
    taxonomy = supertree_toolkit.load_taxonomy(taxonomy) # load it in and create the dictionary

    try:
        newXML = supertree_toolkit.generate_species_level_data(XML,taxonomy,verbose=verbose,ignoreWarnings=ignoreWarnings)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to carry out auto subs.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to carry out auto subs.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to carry out auto subs.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.NoneCompleteTaxonomy as detail:
        msg = "***Error: Failed to carry out auto subs.\n"+detail.msg
        print msg
        return
    except:
        # what about no internet conenction? What error do that throw?
        msg = "***Error: failed to carry out auto subs due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit"
        print msg
        traceback.print_exc()
        return

    f = open(output,"w")
    f.write(newXML)
    f.close()


def process(args):

    verbose = args.verbose
    input_file = args.input
    output = args.output
    no_store = args.no_store
    ignoreWarnings = args.ignoreWarnings
    taxonomy_file = args.taxonomy_file
    equivalents_file = args.equivalents_file
    overwrite = args.overwrite
    pref_db = args.pref_db

    if (os.path.exists(output) and not overwrite):
        print "Output matrix file exists. Either remove the file or use the --overwrite flag."
        print "Do you wish to continue and overwrite the file anyway? [Y/n]"
        while True:
            k=inkey()
            if k.lower() == 'n':
                print "Exiting..."
                sys.exit(0)
            if k.lower() == 'y':
                break

    filename = os.path.basename(input_file)
    dirname = os.path.dirname(input_file)

    if verbose:
        print "Loading and checking your data"
    # 0) load and check data
    try:
        phyml = supertree_toolkit.load_phyml(input_file)
        project_name = supertree_toolkit.get_project_name(phyml)
        phyml = supertree_toolkit.clean_data(phyml)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to load data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to load data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to load data.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed to load input due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 

    if verbose:
        "Removing subspecies"
    phyml = _remove_subspecies(phyml) 
    phyml = supertree_toolkit.clean_data(phyml)
    
    
    if verbose:
        print "Checking taxa againt online databases"
    # 1) taxonomy checker with autoreplace
    # Load existing data if any:
    if (not equivalents_file == None):
        equivalents = supertree_toolkit.load_equivalents(equivalents_file)
    else:
        equivalents = None
    equivalents = supertree_toolkit.taxonomic_checker(phyml,existing_data=equivalents,pref_db=pref_db,verbose=verbose)    
    # save the equivalents for later (as CSV and as sub file)
    data_string_csv = _equivalents_to_csv(equivalents)
    data_string_subs = _equivalents_to_subs(equivalents)
    f = open(os.path.join(dirname,project_name+"_taxonomy_checker.csv"), "w")
    f.write(data_string_csv)
    f.close()
    f = open(os.path.join(dirname,project_name+"_taxonomy_check_subs.dat"), "w")
    f.write(data_string_subs)
    f.close()
    
    # now do the replacements - we use the subs file :)
    if verbose:
        print "Swapping in the corrected taxa names"    
    try:
        old_taxa, new_taxa = supertree_toolkit.load_subs_file(os.path.join(dirname,project_name+"_taxonomy_check_subs.dat"))
    except supertree_toolkit.UnableToParseSubsFile as e:
        print e.msg
        sys.exit(-1)
        
    try:
        phyml = supertree_toolkit.substitute_taxa(phyml,old_taxa,new_taxa,only_existing=False,verbose=verbose)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed substituting taxa.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed sbstituting taxa due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 
    # save phyml as intermediate step
    phyml = supertree_toolkit.clean_data(phyml)
    f = open(os.path.join(dirname,project_name+"_taxonomy_checked.phyml"), "w")
    f.write(phyml)
    f.close()

    
    if verbose:
        print "Creating taxonomic information"    
    # 2) create taxonomy
    if (not taxonomy_file == None):
        taxonomy = supertree_toolkit.load_taxonomy(taxonomy_file)
    else:
        taxonomy = None
    taxonomy = supertree_toolkit.create_taxonomy(phyml,existing_taxonomy=taxonomy,pref_db=pref_db,verbose=verbose)
    if verbose:
        print "Checking other databases to see if we can add more data to taxonomy"
    #taxonomy = supertree_toolkit.create_extended_taxonomy(taxonomy, pref_db=pref_db, verbose=verbose)
    # save the taxonomy for later
    # Now create the CSV output - seperate out into function in STK (used several times)
    supertree_toolkit.save_taxonomy(taxonomy, os.path.join(dirname,project_name+"_taxonomy.csv"))

    # 3) create species level dataset
    if verbose:
        print "Converting data to species level"
    try:
        phyml = supertree_toolkit.generate_species_level_data(phyml,taxonomy,verbose=verbose)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to carry out auto subs.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to carry out auto subs.\n"+detail.msg
        print msg
        return
    except UninformativeTreeError as detail:
        msg = "***Error: Failed to carry out auto subs.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.NoneCompleteTaxonomy as detail:
        msg = "***Error: Failed to carry out auto subs.\n"+detail.msg
        print msg
        return
    except:
        # what about no internet conenction? What error do that throw?
        msg = "***Error: failed to carry out auto subs due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit"
        print msg
        traceback.print_exc()
        return
    # save the phyml as intermediate step
    f = open(os.path.join(dirname,project_name+"_species_level.phyml"), "w")
    f.write(phyml)
    f.close()

    # 4) Remove non-monophyletic taxa (requires TNT to be installed)
    if verbose:
        print "Removing non-monophyletic taxa via mini-supertree method"
    tree_list = supertree_toolkit.find_trees_for_permuting(phyml)
    try:
        for t in tree_list:
            # permute
            output_string = supertree_toolkit.permute_tree(tree_list[t],matrix='hennig',treefile=None,verbose=verbose)
            #save
            if (not output_string == ""):
                file_name_t = os.path.basename(filename)
                dirname_t = os.path.dirname(filename)
                new_output = os.path.join(dirname_t,t,t+"_matrix.tnt")
                try: 
                   os.makedirs(os.path.join(dirname_t,t))
                except OSError:
                    if not os.path.isdir(os.path.join(dirname_t,t)):
                        raise
                f = open(new_output,'w',0)
                f.write(output_string)
                f.close
                time.sleep(1)

                # now create the tnt command to deal with this
                # create a tmp file for the output tree
                temp_file_handle, temp_file = tempfile.mkstemp(suffix=".tnt")
                tnt_command = "tnt mxram 512,run "+new_output+",echo= ,timeout 00:10:00,rseed0,rseed*,hold 1000,xmult= level 0,taxname=,nelsen *,tsave *"+temp_file+",save /,quit"
                #tnt_command = "tnt run "+new_output+",ienum,taxname=,nelsen*,tsave *"+temp_file+",save /,quit"
                # run tnt, grab the output and store back in the data
                try:
                    call(tnt_command, shell=True)
                except CalledProcessError as e:
                    msg = "***Error: Failed to run TNT. Is it installed correctl?.\n"+e.msg
                    print msg
                    return

                new_tree = supertree_toolkit.import_tree(temp_file)
                phyml = supertree_toolkit.swap_tree_in_XML(phyml,new_tree,t)

    except supertree_toolkit.TreeParseError as e:
        msg = "***Error permuting trees.\n"+e.msg
        print msg
        return

    #4.5) remove MRP_Outgroups
    phyml = supertree_toolkit.substitute_taxa(phyml,'MRP_Outgroup')
    phyml = supertree_toolkit.substitute_taxa(phyml,'MRPOutgroup')
    phyml = supertree_toolkit.substitute_taxa(phyml,'MRP_outgroup')
    phyml = supertree_toolkit.substitute_taxa(phyml,'MRPoutgroup')
    phyml = supertree_toolkit.substitute_taxa(phyml,'MRPOUTGROUP')  

    # save intermediate phyml
    f = open(os.path.join(dirname,project_name+"_nonmonophyl_removed.phyml"), "w")
    f.write(phyml)
    f.close()

    # 5) Remove common names
    # no function to do this yet...

    # 6) Data independance
    if verbose:
        print "Checking data independence"
    data_ind,subsets,phyml = supertree_toolkit.data_independence(phyml,make_new_xml=True)
    # save phyml
    f = open(os.path.join(dirname,project_name+"_data_ind.phyml"), "w")
    f.write(phyml)
    f.close()

    # 7) Data overlap
    if verbose:
        print "Checking data overlap"
    sufficient_overlap, key_list = supertree_toolkit.data_overlap(phyml,verbose=verbose)
    # process the key_list to remove the unconnected trees
    if not sufficient_overlap:
        # we don't, have enough, then remove all but the largest group.
        # First, find the largest group
        lrg=0
        indx=0
        i = 0
        for k in key_list:
            if len(list(k)) > lrg:
                indx = i
            i += 1

        delete_me = []
        for t in key_list[indx::]: # skip 0
            delete_me.extend(t)
        for tree in delete_me:
            phyml = supertree_toolkit.swap_tree_in_XML(phyml, None, tree, delete=True) # delete the tree and clean the data as we go 
    # save phyml
    f = open(os.path.join(dirname,project_name+"_data_tax_overlap.phyml"), "w")
    f.write(phyml)
    f.close()

    # 8) Create matrix
    if verbose:
        print "Creating matrix"
    try:
        matrix = supertree_toolkit.create_matrix(phyml)
    except supertree_toolkit.NotUniqueError as detail:
        msg = "***Error: Failed to create matrix.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.InvalidSTKData as detail:
        msg = "***Error: Failed to create matrix.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.UninformativeTreeError as detail:
        msg = "***Error: Failed to create matrix.\n"+detail.msg
        print msg
        return
    except supertree_toolkit.TreeParseError as detail:
        msg = "***Error: failed to parse a tree in your data set.\n"+detail.msg
        print msg
        return
    except: 
        msg = "***Error: Failed to create matrix due to unknown error. File a bug report, please!\nhttps://bugs.launchpad.net/supertree-toolkit\n"
        print msg
        traceback.print_exc()
        return 

    f = open(output, "w")
    f.write(matrix)
    f.close()

    return


def _equivalents_to_csv(equivalents):

    output_string = 'Taxa,Equivalents,Status\n'

    for taxon in sorted(equivalents):
        output_string += taxon + "," + ';'.join(equivalents[taxon][0]) + "," + equivalents[taxon][1] + "\n"

    return output_string


def _equivalents_to_subs(equivalents):
    """Only corrects the yellow and amber ones. Red and green are left alone"""

    output_string = ""
    for taxon in sorted(equivalents):
        if (equivalents[taxon][1] == 'yellow' or
            equivalents[taxon][1] == 'amber'):
            # the first name is always the correct one, but check if it's the same level, i.e
            # don't replace a gneus with a species (don't want that!)
            if type(equivalents[taxon][0]) is list:
                if len(taxon.split("_")) == len(equivalents[taxon][0][0].split("_")):
                    output_string += taxon + " = "+equivalents[taxon][0][0]+"\n"
            else:
                if len(taxon.split("_")) == len(equivalents[taxon][0].split("_")):
                    output_string += taxon + " = "+equivalents[taxon][0]+"\n"
    return output_string


def _remove_subspecies(XML):

    taxa = supertree_toolkit.get_all_taxa(XML)
    delete_me = []
    replace_with = []
    for t in taxa:
        if len(t.split("_")) >= 3: # subspecies
            delete_me.append(t)
            replace_with.append("_".join(t.split("_")[0:2]))


    phyml = supertree_toolkit.substitute_taxa(XML,delete_me,replace_with)

    return phyml



if __name__ == "__main__":
    main()


